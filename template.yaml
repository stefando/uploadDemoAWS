AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: Multi-tenant file upload service with Cognito authentication and S3 storage

# Global configuration for all resources
Globals:
  Function:
    Timeout: 30
    MemorySize: 256
    # Using the provided.al2023 Lambda runtime for execution
    Runtime: provided.al2023
    Architectures:
      - x86_64

Parameters:
  DomainName:
    Type: String
    Default: stefando.me
    Description: The domain name for the API (Route53 hosted zone must exist)
  
  ApiSubdomain:
    Type: String
    Default: upload-api
    Description: Subdomain for the API endpoint
    
  HostedZoneId:
    Type: String
    Description: ID of the Route53 hosted zone for the domain
    Default: ''

Resources:
  # ================================================
  # COGNITO USER POOL - Authentication Service
  # ================================================
  # User Pool manages user accounts and authentication
  # Think of it as your user database + authentication logic
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: upload-demo-user-pool
      # Password policy for security
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      # Auto-verify email addresses (for production, you'd want email verification)
      AutoVerifiedAttributes:
        - email
      # Schema defines what user attributes we collect
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: tenant_id
          AttributeDataType: String
          Required: false
          Mutable: true
      # Lambda triggers for adding custom claims to JWT (V2_0 enables access token customization)
      LambdaConfig:
        PreTokenGenerationConfig:
          LambdaArn: !GetAtt PreTokenGenerationLambda.Arn
          LambdaVersion: "V2_0"

  # User Pool Client - handles JWT token generation
  # This is what your frontend application uses to authenticate users
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: upload-demo-client
      # Explicit auth flows - these determine how clients can authenticate
      ExplicitAuthFlows:
        - ADMIN_NO_SRP_AUTH  # Allow admin-initiated auth (for testing)
        - USER_PASSWORD_AUTH # Allow username/password auth
      # Token validity periods
      AccessTokenValidity: 1  # 1 hour
      IdTokenValidity: 1      # 1 hour
      RefreshTokenValidity: 30 # 30 days
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days

  # ================================================
  # LAMBDA FOR CUSTOM JWT CLAIMS
  # ================================================
  # This Lambda adds the tenant_id claim to JWT tokens
  # It's triggered before Cognito generates tokens
  PreTokenGenerationLambda:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: upload-demo-pre-token-generation
      CodeUri: .aws-sam/build/PreTokenGenerationLambda/function.zip
      Handler: bootstrap
      Runtime: provided.al2023
      Environment:
        Variables:
          # Environment variables for the Lambda
          LOG_LEVEL: INFO
      # Lambda is associated with Cognito via LambdaConfig, not through Events
      # SAM doesn't support Cognito triggers via the Events property

  # Permission for Cognito to invoke the pre-token Lambda
  PreTokenGenerationLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref PreTokenGenerationLambda
      Action: lambda:InvokeFunction
      Principal: cognito-idp.amazonaws.com
      SourceArn: !GetAtt UserPool.Arn

  # Permission for API Gateway to invoke the tenant authorizer Lambda
  TenantAuthorizerLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref TenantAuthorizerFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/authorizers/*"

  # ================================================
  # S3 BUCKETS - File Storage
  # ================================================
  # Separate bucket for each tenant ensures data isolation
  TenantABucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-store-tenant-a"
      # Block public access for security
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      # Tagging for access control
      Tags:
        - Key: TenantId
          Value: tenant-a
        - Key: Purpose
          Value: FileStorage

  TenantBBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub "${AWS::StackName}-store-tenant-b"
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: TenantId
          Value: tenant-b
        - Key: Purpose
          Value: FileStorage

  # ================================================
  # IAM ROLE FOR MAIN LAMBDA FUNCTION
  # ================================================
  # This role provides a single execution context with permissions
  # to access our tenant buckets using a prefix-based policy
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${AWS::StackName}-lambda-execution-role"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        # Basic Lambda execution permissions (CloudWatch Logs)
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        # Custom policy for S3 access to tenant buckets
        - PolicyName: TenantBasedS3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Allow S3 operations on all tenant buckets with our prefix
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt TenantABucket.Arn
                  - !GetAtt TenantBBucket.Arn
                  - !Sub "${TenantABucket.Arn}/*"
                  - !Sub "${TenantBBucket.Arn}/*"

  # ================================================
  # MAIN LAMBDA FUNCTION - File Upload API
  # ================================================
  UploadFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-upload-function"
      CodeUri: .aws-sam/build/UploadFunction/function.zip
      Handler: bootstrap
      Role: !GetAtt LambdaExecutionRole.Arn
      Environment:
        Variables:
          # Configuration passed to Lambda as environment variables
          TENANT_A_BUCKET: !Ref TenantABucket
          TENANT_B_BUCKET: !Ref TenantBBucket
          USER_POOL_ID: !Ref UserPool
          USER_POOL_CLIENT_ID: !Ref UserPoolClient
          LOG_LEVEL: INFO
      Events:
        # API Gateway integration for upload endpoint (requires authentication)
        Upload:
          Type: Api
          Properties:
            RestApiId: !Ref ApiGateway
            Path: /upload
            Method: POST
            Auth:
              Authorizer: TenantVerificationAuthorizer
              
        # Health check endpoint (no authentication required)
        Health:
          Type: Api
          Properties:
            RestApiId: !Ref ApiGateway
            Path: /health
            Method: GET

  # ================================================
  # TENANT AUTHORIZER LAMBDA - Custom JWT Claims Validation
  # ================================================
  # This Lambda verifies tenant_id claim presence after Cognito validation
  TenantAuthorizerFunction:
    Type: AWS::Serverless::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-tenant-authorizer"
      CodeUri: .aws-sam/build/TenantAuthorizerFunction/function.zip
      Handler: bootstrap
      Runtime: provided.al2023
      Environment:
        Variables:
          LOG_LEVEL: INFO
          COGNITO_POOL_ID: !Ref UserPool
          COGNITO_CLIENT_ID: !Ref UserPoolClient
          COGNITO_REGION: !Ref AWS::Region
      Policies:
        - Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action: 'execute-api:Invoke'
              Resource: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:*/*/*/*'

  # ================================================
  # API GATEWAY CLOUDWATCH LOGS ROLE
  # ================================================
  ApiGatewayCloudWatchLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs

  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchLogsRole.Arn

  # ================================================
  # API GATEWAY - HTTP API Endpoint
  # ================================================
  ApiGateway:
    Type: AWS::Serverless::Api
    DependsOn: ApiGatewayAccount
    Properties:
      Name: !Sub "${AWS::StackName}-api"
      StageName: prod
      # Enable API Gateway execution logging
      MethodSettings:
        - HttpMethod: "*"
          ResourcePath: "/*"
          LoggingLevel: INFO
          DataTraceEnabled: true
          MetricsEnabled: true
      # Authorization configuration  
      Auth:
        Authorizers:
          # Lambda authorizer for Cognito JWT validation + tenant verification
          TenantVerificationAuthorizer:
            FunctionPayloadType: REQUEST
            FunctionArn: !GetAtt TenantAuthorizerFunction.Arn
            AuthorizerResultTtlInSeconds: 0
            Identity:
              Headers:
                - X-Auth-Token
      # CORS configuration for web clients
      Cors:
        AllowMethods: "'GET,POST,OPTIONS'"
        AllowHeaders: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token,X-Auth-Token'"
        AllowOrigin: "'*'"
      # Custom domain configuration
      Domain:
        DomainName: !Sub "${ApiSubdomain}.${DomainName}"
        CertificateArn: !Ref ApiCertificate
        EndpointConfiguration: REGIONAL
        Route53:
          HostedZoneId: !Ref HostedZoneId

  # ================================================
  # SSL CERTIFICATE - HTTPS Security
  # ================================================
  ApiCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Sub "${ApiSubdomain}.${DomainName}"
      ValidationMethod: DNS
      DomainValidationOptions:
        - DomainName: !Sub "${ApiSubdomain}.${DomainName}"
          HostedZoneId: !Ref HostedZoneId

  # No need to define HostedZone resource as we're using the HostedZoneId parameter

# ================================================
# OUTPUTS - Information for other systems/testing
# ================================================
Outputs:
  ApiUrl:
    Description: API Gateway endpoint URL
    Value: !Sub "https://${ApiSubdomain}.${DomainName}/prod"
    Export:
      Name: !Sub "${AWS::StackName}-api-url"

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub "${AWS::StackName}-user-pool-id"

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub "${AWS::StackName}-user-pool-client-id"

  TenantABucket:
    Description: S3 bucket for tenant A
    Value: !Ref TenantABucket
    Export:
      Name: !Sub "${AWS::StackName}-tenant-a-bucket"

  TenantBBucket:
    Description: S3 bucket for tenant B
    Value: !Ref TenantBBucket
    Export:
      Name: !Sub "${AWS::StackName}-tenant-b-bucket"